# -*- coding: utf-8 -*-
"""Copy of Examen01_2024_1.version2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CUSeeoPRpq3VLxWPklD5EKB8NNKud3Hf

<a href="https://colab.research.google.com/github/hernansalinas/autogradesMetodosComputacionales/blob/main/Evaluaciones/Examen01_2024_1.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Examen 1: Métodos computacionales.

## Profesor: Hernán Salinas
### Universidad de Antioquia


El examen consta de 7 puntos, cada uno de igual valor, el uso de herramientas de IA no esta permitido. Puede usar la documentacion de scipy, numpy, matplotlib.

La entrega se realiza a través del github del curso.


#### Examen

Una esfera de masa $m$ es lanzada desde la superficie de la tierra con velocidad $\vec{v_0}$. Las fuerzas que actúan sobre la bolita son: el peso $m\vec{g}$, y la fuerza de rozamiento $\vec{f}=-mb\vec{v}_0$ que el  aire ejerce sobre la bolita. Un digrama de cuerpo libre es esquematizado en la siguiente figura.

![Movimiento parabolico](http://www.sc.ehu.es/sbweb/fisica/dinamica/stokes2/stokes1.gif)

Para dar solución al movimiento de la bolita, se debe plantear las ecuaciones de movimiento desde la segunda ley de Newton y después solucionarla para encontrar la ecuaciones de posición y velocidad. Su tarea será determinar el valor del alcance máximo para diferentes ángulos de lanzamiento. Para ello lea detenidamente lo siguiente:  

Las **ecuaciones de movimiento** de la bolita vienen dadas por:
\begin{equation}
m\frac{\mathrm{d}v_x}{\mathrm{d}t} = - mbv_x
\end{equation}


\begin{equation}
m\frac{\mathrm{d}v_y}{\mathrm{d}t} = - mg-mbv_y
\end{equation}


donde:

$v_{0x}=v_0\cos \theta$,  $v_{0y}=v_0\sin \theta$,  $b$ el coeficiente de rozamiento con el aire, y $g$ la aceleración de la gravedad


La solución a las ecuaciones anteriores para la **posición ($x$, $y$) y la velocidad ($v_x$, $v_y$)**  son:


\begin{equation}
x =  \frac{v_{0x}}{b}\left( 1-e^{-bt} \right)
\end{equation}

\begin{equation}
y =  \frac{1}{b}\left( \frac{g}{b}+v_{0y}\right)(1-e^{-bt})-\frac{g}{b}t
\end{equation}


\begin{equation}
v_x = v_{0x}e^{-bt}
\end{equation}

\begin{equation}
v_y = \left(\frac{g}{b}+v_{0y} \right) e^{-bt}-\frac{g}{b}
\end{equation}



**Alcance máximo**

El tiempo asociado al alcance máximo del proyectil se da cuando $x=R$, asi podemos despejar  de la ecuación para $x$ el tiempo:

\begin{equation}
t_v=-\frac{1}{b} \ln \left(1-\frac{Rb}{v_{0x}} \right)
\end{equation}

El alcance máximo R, estará deteminado cuando $y=0$ en la siguiente ecuación  ecuación trascendental.


\begin{equation}
y =\left(\frac{g}{b} + v_{0y}  \right) \frac{R}{v_{0x}}+\frac{g}{b^2}\ln \left(1-\frac{Rb}{v_{0x}} \right)
\end{equation}

 Su tarea será determinar el valor de R para diferentes ángulos de lanzamiento, para ello realice lo siguiente:





1. Construir una función de python paramétrica para determinar el valor de R.
$y = f(R, \theta, v_{ox},v_{oy},b,g)$



2. Asumiento que la bolita es lanzada con una rapidez de
$v_0=55\mathrm{m}/\mathrm{s}$ y un ángulo de $45^{\circ}$ respecto a la horizontal, $b=0.005$ y $g=9.8\mathrm{m}/\mathrm{s^2}$, determine el alcance máximo. Emplee el método que desee.


3. Valide el resutado anterior, con un método diferente al que empleo en el apartado anterior y además, determine el tiempo de vuelo $t_v$.  


4. Construya una gráfica de $x$ vs $t$, $y$ vs $t$, $x$ vs $y$. Asegurese de  no superar en las trayectorias los tiempos establecidos por el  tiempo de vuelo $t_v$.

Ahora,  vamos a mostrar la trayectoria para múltiples ángulos de lanzamiento.

5. Suponiendo,  $b=0.009$, $v_0 = 40\mathrm{m}/\mathrm{s}$ y  $\theta$ entre $0<\theta<90^{\circ}$ en pasos de $5^{\circ}$:
```python
theta=np.arange(0, 90, 5)
theta=np.deg2rad(theta)
```


generalice el resultado del punto  número 2  para determinar el conjunto de valores de R asociados a cada ángulo. Con lo anterior determine los tiempos de vuelo.

6. Realice un gráfico de $R$ vs $t_v$

7. Finalmente, construya todas las trayectorias ($y$ vs $x$) para cada ángulo $\theta$.
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy import optimize

#Datos
v0=55
thet_radianes=np.rad2deg(45)
b=0.005
g=9.8

# funcion de la velocidad en x
def v0_x(v0,theta):
  return v0*np.cos(theta)

v0_x1=v0_x(55,thet_radianes)
print("el valor de la velocidad en la componente x es :",v0_x1)

#funcion de la velocidad en y
def v0_y(v0,theta):
  return v0*np.sin(theta)

v0_y1=v0_y(55,thet_radianes)
print("el valor de la velocidad en la componente y es:",v0_y1)

# Funcion parametrica, busco donde y=0, el resultado que me de es el valor de R, al encontrar el valor de R puedo reemplazarlo en la ecuacion del timepo y encontrar el tiempo en ese momento
#cuando se el tiempo en ese momento puedo hacer el resto de puntos, pero no se porque no me da la grafica :'( y usted esta ocupado para preguntarle
v0=55
theta=45
thet_radianes=np.deg2rad(45)
b=0.005
g=9.8
v0_y1=v0_y(55,thet_radianes)
v0_x1=v0_x(55,thet_radianes)

def funcion(R,g,b,v0_x1,v0_y1):
  return (((g)/(b))+(v0_y1))*((R)/(v0_x1))      +    ((g)/(b**2))    *     (np.log(1-(R*b)/(v0_x1)))

R=np.linspace(-5,305,100)
y=funcion(R,g,b,v0_x1,v0_y1)
plt.plot(R,y)
plt.title("R en funcion de Y")
plt.xlabel("R")
plt.ylabel("Y")
plt.grid()
plt.show()

d={"funcion":R , "funcion1":y}
df=pd.DataFrame(d)
df

R=np.linspace(-0.5,0.5,100)
y=funcion(R,g,b,v0_x1,v0_y1)
plt.plot(R,y)
plt.grid()
plt.show()

#metodo de la biseccion, la primera raiz
raiz=optimize.bisect(funcion,-0.5,0.4,args=(g,b,v0_x1,v0_y1))
raiz_redondeo=round(raiz,10)
print("La raiz sin aproximar es",raiz)
print("la raiz aproximada a 10 cifras decimales es", raiz_redondeo)

#la segunda raiz

R=np.linspace(200,350,100)
y=funcion(R,g,b,v0_x1,v0_y1)
plt.plot(R,y)
plt.grid()
plt.show()

#metodo de la biseccion,segunda raiz

R=optimize.bisect(funcion,300.64,300.7,args=(g,b,v0_x1,v0_y1))
R_redondeo=round(raiz,10)

print("la raiz aproximada a 10 cifras decimales es", raiz_redondeo)
print("el valor de R es:", R)

#me quedare con la segunda raiz porque es la menos obvia, metodo de la secante
R_newton=optimize.newton(funcion,300.70,args=(g,b,v0_x1,v0_y1))
print("la raiz por el metodo de la secante es:",R_newton)

#funcion de x
def fx(t,v0_x1,b):
  return ((v0_x1)/(b)) * (1-np.exp(-b*t))

#funcion de t
def ft(b,R,v0_x1):
  return (-1)/(b) * np.log(1-(R*b)/(v0_x1))


print("el tiempo de vuelo es:" ,ft(b,R_newton,v0_x1))

#funcion de Y en funcion del tiempo
def fy(t,v0_y1,b):
  return ((1)/(b))* ((g)/(b)+ v0_y1) *  (1-np.exp(-b*t)) - ((g)/(b))*(t)

#el alcance maximo es R, en ese punto la velocidad es cero y el tiempo de vuelo seria desde que empezo en cero hasta que llego a R, pero R es solo la mitad de la trayectoria
#por tanto el intervalo del tiempo deberia de ser
Tto=ft(b,R_newton,v0_x1)+ft(b,R_newton,v0_x1)
Tto

def funcion(R,g,b,v0_x1,v0_y1):
  return (((g)/(b))+(v0_y1))*((R)/(v0_x1))      +    ((g)/(b**2))    *     (np.log(1-(R*b)/(v0_x1)))

#Grafica de x en funcion del tiempo

ft=np.linspace(0,Tto)
x=fx(ft,v0_x1,b)
plt.plot(ft,x)
plt.xlabel("TIEMPO")
plt.ylabel("X")
plt.title("X en funcion del tiempo")
plt.show()

#Grafica de Y en funcion del tiempo
ft=np.linspace(0,Tto)
x=fy(ft,v0_y1,b)
plt.plot(ft,x)
plt.xlabel("TIEMPO")
plt.ylabel("Y")
plt.title("Y en funcion del tiempo")
plt.show()

#Un analisis del punto

theta=np.arange(0, 90, 5)
theta_b=np.deg2rad(theta)
theta_b # esto me da una lista de numeros que necesito recorrer

# necesito saber la longitud de la lista
len(theta_b)

# necesito recorrer cada valor de esa lista y guardarla, lo que va variando es v0_x y v0_y ya que de estas funciones depende theta que es el angulo y este es el que esta variando.
#en cada iteracion encontrare un nuevo valor de v0_x y v0_y que tengo que guardar en dos listas, una para los nuevos valores de v0_x y otra para los valores de v0_y

def v0_x(v0,theta):
  return v0*np.cos(theta)

#funcion de la velocidad en y
def v0_y(v0,theta):
  return v0*np.sin(theta)

#para no hacer el proceso mas complicado podria redefinir mi funcion y que en ella se varie v0_x y v0_y y asi no tengo que complicar tanto todo

v0=55
theta=45
thet_radianes=np.deg2rad(45)
b=0.005
g=9.8


def funcion1(R,g,b,v0_x1,v0_y1):
  return(((g)/(b)) + (v0)*np.sin(theta_b)) * ((R)/((v0)*np.cos(thet_b))) + ((g)/(b**2)) * np.log(1-((R)*(b))  /  ((v0)(np.cos(thet_b))))

# con esta funcion1 puedo ir recorriendola y guardar los valores

theta=np.arange(0, 90, 5)
theta_b=np.deg2rad(theta)
theta_b

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy import optimize

#Variables:
g = 9.8; b = 0.009; v0 = 40

theta=np.arange(0, 90, 5)
theta_a=np.deg2rad(theta)

raices = []
def funcion1(R,theta):
  return(((g)/(b)) + (v0)*np.sin(theta)) * ((R)/((v0)*np.cos(theta))) + ((g)/(b**2)) * np.log(1-((R)*(b))  /  ((v0)*(np.cos(theta))))


for i in theta_a:
  raices.append(optimize.bisect(funcion1,280,320,args=(i)))
  #Profe hola, profe todo lo que entrego hasta aqui es trabajo honesto, no tuve ayuda de nadie, me quede toda la tarde intentando hacer el punto 5 pero no fui capaz y si digo que lo hice mentiria porque buscaria ayuda de alguien mas
  #gracias por la oportunidad y por la confianza, lo que entrego aqui es lo que se

x = np.arange(0,10,2)
def f(a,x):
  return a*x

f(2,x)

def funcion1(R,theta=np.pi/2):
  return(((g)/(b)) + (v0)*np.sin(theta)) * ((R)/((v0)*np.cos(theta))) + ((g)/(b**2)) * np.log(1-((R)*(b))  /  ((v0)*(np.cos(theta))))

R=np.arange(-1,1,0.1)
y=funcion1(R)
plt.plot(R,y)
plt.show()

